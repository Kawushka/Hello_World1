# print(dict(a='b', v = 'd'))
# print(dict([(1,1),(2,4),(3,5)]))
# d = {}
# d = {"abc":1}
# d = dict.fromkeys(['a','b'], 100)
# d = {i:i*6 for i in 'abcdef'}
# print(d)

# goods = {'Apple':[4.5, 10], #ключ Apple, значение - список, где 4.5 это стоимость, 10 это количество
#          'Banana':[6.5, 20],
#          'Orange':[6.2, 5],
#          'Mango':[7.5, 2]
#          }
# for key, value in goods.items(): # в таком цикле key обходит все ключи, value все значения
#     print(f'{key} - {value[0]} - {value[1]}')
# good=''
# price = 0 #итоговая стоимость покупки
# while True: #бесконечный цикл
#     good = input('Что вы хотите купить? (n - выход) ') #спрашиваем название товара
#     if good == 'n' or good not in goods.keys(): break #условие выхода из цикла
#     kol = int(input('Сколько: ')) #спрашиваем количество товара
#     if kol > goods[good][1]: #в случае, если на складе нет столько товара
#         print('Столько товаров нет!')
#         continue
#     price += kol * goods[good][0] #увеличиваем счетчик стоимости покупок
#     goods[good][1] -= kol #уменьшаем количество товара на складе
# print('Итоговая цена: ', price) #печать итоговой стоимости
# for key, value in goods.items(): # печать остатка на складе
#     print(f'{key} - {value[0]} - {value[1]}')


#Множества (set) - встроенный тип данных с неупорядоченными элементами (нет индексов).
#Особенности:
#1. Нет дубликатов среди элементов
#2. Сами элементы неизменяемые, но множество изменяемое (можно добавлять и удалять элементы)
#3. Нельзя делать срезы и индексирование (так как нет индексов)

# num_set = {1,2,3,4,6,5} #первый способ создания множества
# print(num_set) #печать в порядке возрастания

#Все элементы могут быть разных типов, которые не поддерживают изменения. Нельзя использовать списки, словари и т.д.
# string_set = {'abc', 'Dmitry', 'John'} #множество из строк
# print(string_set) #печать в случайном порядке

# mixed_set = {2.0, 'Nick', (1,2,3)}
# print(mixed_set) #печать в случайном порядке

# spisok = [1,2,3,4,5,6]
# num_set = set(spisok) #создание множества через встроенную функцию set
# print(num_set)
# print(set(spisok))

# num_set = {1,2,3,3,4,1,2}
# print(num_set) #удаляются дубликаты

# x = {} #создан пустой словарь, а не множество
# print(type(x))

# x = set() #создаем пустое множество
# print(type(x))

# months = set(['Jan','Feb','March'])
# for i in months: #цикл обходит множество ориентируясь лишь по названиям элементов
#     print(i) #печать всех элементов множества

# print('Feb' in months) #находится ли элемент в множестве

# months.add('April') #добавляет элемент на случайное место
# print(months)

#Удаление элементов множества - методы .discard(x), .remove(x)
# num_set = {1,2,3,4,6,5}
# num_set.discard(5)
# num_set.remove(5)
# num_set.discard(7) #ошибка не возникнет, хотя такого элемента нет
# num_set.remove(7) #выдаст ошибку
# num_set.pop() #в случае с числами удаляет первый элемент множества
# print(num_set)

# str_set = {'abc', 'g', 'h','j'}
# str_set.pop() #удаляет случайный элемент
# print(str_set)
# print(str_set.pop()) #выводим на печать случайный удаленный элемент

# str_set.clear() #полностью очищает множество
# print(str_set)

# months_A = set(['Jan','Feb', 'March', 'April','May','June'])
# months_B = set(['Jule','Aug','Sep','Oct','Nov','Dec'])
# #Union - объединение нескольких множеств в одно
# all_months = months_A.union(months_B) #первое множество months_A объединили со вторым множеством months_B
# print(all_months)

# x = {1,2,3}
# y = {4,3,6}
# z = {7,4,9}
#
# output = x.union(y,z) #множество x объединили c y,z
# print(output)
# print(x|y|z)

# months_A = set(['Jan','Feb', 'March', 'April','May','June'])
# months_B = set(['Jule','Aug','Sep','Oct','Nov','Dec'])
# print(months_A | months_B) #краткая конструкция объединения множеств

# x = {1,2,3}
# y = {4,3,6}
# z = {7,4,9}
#
# #Intersection (&) - пересечение нескольких множеств. Покажет элементы, общие для всех множеств
# print(x.intersection(y)) #пересечение
# print(x & y) #краткая запись пересечения

#Разница между множествами ( знак -)
#A-B покажет элементы, которые есть в А, но нет в В. И наоборот
# A = {1,2,3}
# B = {4,3,6}
# print(A-B, B-A) #результаты разные, но в обоих нет тройки

#Методы множеств

# A = {1,2,3}
# x = A.copy()
# B = A
#
# A.add(4)
#
# print(x) # в х сохранилось старое множество
# print(A,B) # в В перенеслись все изменения из А

# x = {1,2,3}
# y = {4,3,6}
# z = {7,4,9}
# print(x.isdisjoint(y)) #isdisjoint спрашивает, нет ли пересечений у множеств. Если нет - выведет True
# print(x.isdisjoint(z)) #выведет True
#
# print(len(x)) #длина множества

# my_set = frozenset([1,2,3,-10,40])
# print(type(my_set))
# #frozenset - неизменяемое множество
# my_set.add(1) #выдаст ошибку, потому что frozenset не поддерживает добавление и удаление элементов



#Task_1. Есть ли в списке дубликаты?
# list1 = [1,2,3,4,5,0,0,5,6,7]
# st = set(list1)
# if len(st) == len(list1): print('Дубликатов нет') #если длины равны, то в списке нет дубликатов, так как set их удаляет
# else: print('Дубликаты есть:', *set([i for i in list1 if list1.count(i)>1])) #постцикл с постусловием

#Task_2
#1. Создадим произвольный словарь
#dct = {1:'value_1',2:'value_2',3:'value_3'}
#2. В словарь добавить новый элемент с ключом типа str и значением типа int
#dct['str_key']=12345
#3. Добавим новую пару tuple:list
#dct[('it','is','tuple')] = [1,2,3,4,5,6,7,8,9,10]
#4. Получить элемент по ключу
# print(dct[2])
# print(dct.get(22, 'Такого ключа нет')) #метод get работает аналогично print(dct[2]), но не вызовет ошибку, если нет ключа
#5. Удалить элемент по ключу
# print(dct.pop(22, 'Такого ключа нет')) #если ключа нет, то выведет заданный текст
# print(dct)
#6. Получить список всех ключей
# print(dct.keys())

#Task_3
#1. Создадим обычное и неизменяемое множество
st = {1,2,3,4}
fst = frozenset([5,6,7,3,8,9])
#2. Сделаем объединение множеств
# print(st | fst)
# print(st.union(fst))
#3. Сделаем пересечение множеств
print(st & fst)
print(st.intersection(fst))

#Task_4.
#Есть текст ''. Указать, сколько было различных слов.
# my_str = 'Целый час психолог объяснял, что его клиент ничего никому не должен. ' \
#          'А после оказалось, что клиент психологу должен 5000 рублей за сеанс )))'.split()
# my_str2 = []
# my_str3 = ''
# for i in my_str:
#     for j in i:
#         if j.isalpha(): my_str3 += j
#     if my_str3 != '': my_str2.append(my_str3)
#     my_str3 = ''
# print(len(my_str2))
# print(len(set(my_str2)))
