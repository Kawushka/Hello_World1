# a = (13244, 43, 'gff')
# b = ['gfgffg', '3443', '434ggf', 145]
# c = 578
# d = 'Anna, go HOme'
# e = True
# def f(x):
#     if type(x) == tuple:
#         print(f'Длина кортежа {x}:', len(x))
#     elif type(x) == list:
#         stroka = 0
#         chislo = 0
#         for i in x:
#             if type(i) == int: chislo += 1
#             elif type(i)==str: stroka +=1
#         print(f'Кол-во строк в {x}: {stroka}, кол-во чисел: {chislo}')
#     elif type(x) == int:
#         chet = 0
#         nechet = 0
#         for i in str(x):
#             if int(i) %2 == 0: chet += 1
#             else: nechet += 1
#         print(f'Кол-во чётных цифр в числе {x}: {chet}, нечётных: {nechet}')
#     elif type(x) == str:
#         glasn = 0
#         soglasn = 0
#         for i in x:
#             if i.lower() in 'aeiou': glasn += 1
#             elif i.isalpha() == True: soglasn += 1
#         print(f'В строке "{x}" кол-во гласных букв: {glasn}, согласных: {soglasn}')
#     else: print('ОК')
# f(a)
# f(b)
# f(c)
# f(d)
# f(e)

#Объектно-ориентированное программирование (ООП)
#Существует 2 подхода к написанию программы:
    #Процедурное программирование - это написание функций и последовательный их вызов в коде нашей программы
    #ООП - написание программы в виде совокупности объектов, каждый из которых принадлежит какому-то классу.
    #Каждый класс образует иерархию таких объектов

#Преимущества ООП:
    #1. Программа состоит из объектов, каждый из которых за собственные данные. Код становится проще и читабельнее
    #2. Принцип наследования - можно наследовать готовые функцию из одного класса в другой
    #3. Ускоряется процесс написания программ.

#Класс - шаблон для создания объектов. В классе реализованы инициализации полей, поведение функций (или методов)
# Класс описывает множество объектов, все они имеют одну структуру и поведение.
# Внутри класса описываются свойства и методы объектов.
# Свойства класса, поля или атрибуты класса - это синонимы
# Методы класса - это те же самые функции, но они описаны внутри класса и оперируют с данными этого класса


#Объект - некая сущность, обладающая некоторым состоянием, поведением, имеет свойства (атрибуты) и операции (методы)
# Объект может принадлежать одному или нескольким классам. Каждый класс определяет поведение объекта.
# Объект класса, объект или экземпляр класса, или экземпляр - это синонимы.
#Объект - конкретный представитель класса

# КЛАСС = СВОЙСТВА + МЕТОДЫ

#Пример класса и объектов:
    #1. Класс "Машины". Объекты: "Грузовик", "Кабриолет", "Легковая машина"
    #2. Класс "Здание". Объекты: "Дом", "Гараж", "Сарай", "Бытовка"

# Парадигмы ООП

#Абстракция - это принцип ООП, по которому объект наделяется свойствами, которые отличают его от других объектов
    #Абстракция позволяет выделить главные свойства объекта
    #Отбросить второстепенные свойства
#Инкапсуляция - принцип ООП, по которому различные методы спрятаны от прямого изменения.
    #Отсутствует доступ к внутреннему устройству компонента
    #Взаимодейтсвие с компонентами осуществляется с помощью интерфейса из публичных методов и полей
    #Виды методов: public, private, protected
#Наследование - создание нового класса на основе уже существующего. Класс-потом перенимает определенные свойства и методы от
# от класса-родителя и наделяется каким-то новыми.
    #КЛасс-потомок = свойства и методы родителя + собственные свойства и методы
    #класс-потомок автоматически наследует все поля и методы от родителя
    #класс-потомок может заменять родительские методы и свойства
#Объект "Дом"
    #Свойства
        # Тип фундамента
        # Материал крыши
        # Количество окон
        # Количество дверей
    #Методы
        #Построить
        #Отремонтировать
        #Заселить
        #Снести
#Объект "Частный дом"
#Свойства
        # Тип фундамента - ун
        # Материал крыши - ун
        # Количество окон -ун
        # Количество дверей -ун
        # Количество комнат
        # Отопление
        # Огород
    #Методы
        #Построить -ун
        #Отремонтировать -ун
        #Заселить -ун
        #Снести -ун
        #Изменить фасад
        #Утепление
        #Сделать пристройку
#Полиморфизм - принцип ООП, по которому происходит различная реализация на основе общего интерфейса
    #ПОлиморфизм - создание одноименных методов в разных классах
    #За одноименными методами могут скрываться разные функционалы, которые соответствуют своему классу.

#class <название класса>:
    # <тело класса>
# class Car:
#     default_color = 'grey' #поле, атрибут, свойство. Является статическим
#     default_weight = 5000
#     def __init__(self, color, weight): #динамические поля принадлежат объекту класса. Нет объекта - нет полей
#         self.mycolor = color
#         self.myweight = weight
#     def turn_on(self):
#         print('тут turn_on')
#         pass
#     def ride(self):
#         pass

#self - это служебное слово, которое является ссылкой на экземпляр класса.
#обычно self передается как первый аргумент в любом методе на языке Python

# <имя объекта> = <имя класса>()
# car_object = Car('black', 12) #создали объект car_object класса Car
#У всех объектов класса есть встроенные атрибуты ( и пользовательские
# print(dir(Car)) #список атрибутов класса
# print(dir(car_object)) #список атрибутов объекта (экземпляр)
# print(car_object.mycolor) #вывели на печать значение свойства color объекта car_object
# car_object.turn_on() #запустили метод turn_on объекта car_object

#Свойства класса могут быть:
    # статическими
    # динамическими

# class Phone:
#     color = 'grey' #статическое
#     model = 'hjf' #статическое

# class Phone:
#     def __init__(self,color, model):
#         self.color = color #динамическое
#         self.model = model #динамическое
# nokia = Phone('red','A2') #так как в классе Phone есть динамические свойства, то их значение прописываем как аргумент класса
# #при создании объекта
# print(nokia.color)
# print(nokia.model)
# #self - указатель на объект. Когда мы создаем объект класса, название объекта это есть self

# class Apple:
#     def __init__(self, amount): #инициализация нужна для создания динамических полей
#         self.my_amount = amount
#     def eat(self, number): #метод eat
#         self.my_amount -= number
# my_apple = Apple(12) #завели объект my_apple с динамическим полем my_amount, которому передали аргумент 12
# my_apple.eat(7) #с помощью метода eat уменьшили значение поля my_amount
# print(my_apple.my_amount) #вывели итоговое значение поля my_amount

# class Apple:
#     def __init__(self, amount,eat): #инициализация нужна для создания динамических полей
#         self.eat_1 = eat
#         self.my_amount = amount - eat
# my_apple = Apple(12,7)
# print(my_apple.my_amount)

#ДЗ на вторник:
#1. Создать класс Example
#2. Создать в классе 2 статические переменные
#3. Создать в классе 2 динамические переменные
#4. В классе прописать 3 метода
    #4.1 Первый метод: создает любую переменную и выводит ее на печать
    #4.2 Второй метод: возвращает сумму двух переменных, которые определены до класса (то есть глобально)
    #4.3 Третий метод: вывести на печать возведение первой динамической переменной в степень второй динамической переменной
#5. Создать объект этого класса
#6. Вывести на печать все три метода
